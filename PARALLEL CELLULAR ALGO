import numpy as np
import matplotlib.pyplot as plt

# --- Grid Setup ---
rows, cols = 15, 15
grid = np.zeros((rows, cols), dtype=int)

# Add some obstacles
obstacles = [(5, i) for i in range(3, 12)] + [(9, i) for i in range(2, 10)]
for o in obstacles:
    grid[o] = 1

# Start and Goal positions
start = (2, 2)
goal = (12, 12)

# Initialize distance matrix
dist = np.full((rows, cols), np.inf)
dist[start] = 0

# --- Parallel Cellular Update Function ---
def parallel_wavefront(dist, grid):
    new_dist = dist.copy()
    for i in range(rows):
        for j in range(cols):
            if grid[i, j] == 0:  # Free cell
                neighbors = []
                for di in [-1, 0, 1]:
                    for dj in [-1, 0, 1]:
                        if abs(di) + abs(dj) == 1:  # 4-connectivity
                            ni, nj = i + di, j + dj
                            if 0 <= ni < rows and 0 <= nj < cols:
                                neighbors.append(dist[ni, nj])
                min_neigh = np.min(neighbors) if neighbors else np.inf
                new_dist[i, j] = min(new_dist[i, j], 1 + min_neigh)
    return new_dist

# --- Parallel Wave Expansion ---
iterations = 0
while np.isinf(dist[goal]) and iterations < 100:
    dist = parallel_wavefront(dist, grid)
    iterations += 1

print(f"Wavefront converged in {iterations} iterations")

# --- Path Reconstruction ---
path = []
if not np.isinf(dist[goal]):
    current = goal
    path.append(current)
    while current != start:
        i, j = current
        neighbors = []
        for di in [-1, 0, 1]:
            for dj in [-1, 0, 1]:
                if abs(di) + abs(dj) == 1:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < rows and 0 <= nj < cols:
                        neighbors.append(((ni, nj), dist[ni, nj]))
        current = min(neighbors, key=lambda x: x[1])[0]
        path.append(current)
    path.reverse()
else:
    print("No path found!")

# --- Visualization ---
plt.figure(figsize=(7,7))
plt.imshow(grid, cmap='gray_r', origin='upper')
for (r, c) in path:
    plt.scatter(c, r, color='lime', s=80, label='Path' if (r,c)==path[0] else "")
plt.scatter(start[1], start[0], color='blue', s=150, label='Start')
plt.scatter(goal[1], goal[0], color='red', s=150, label='Goal')
plt.title('Grid-based Robot Routing using Parallel Cellular Algorithm')
plt.legend()
plt.grid(True)
plt.show()
