import numpy as np
import matplotlib.pyplot as plt

# --- Problem setup ---
start = np.array([0, 0])
goal = np.array([10, 10])
obstacles = [
    {"center": np.array([5, 5]), "radius": 2},
    {"center": np.array([7, 2]), "radius": 1.5}
]

n_waypoints = 5  # number of intermediate points
n_particles = 50
max_iters = 100

# --- Helper functions ---
def path_length(points):
    total = 0
    for i in range(len(points) - 1):
        total += np.linalg.norm(points[i+1] - points[i])
    return total

def collision_penalty(points):
    penalty = 0
    for obs in obstacles:
        for p in points:
            dist = np.linalg.norm(p - obs["center"])
            if dist < obs["radius"]:
                penalty += 1000 * (obs["radius"] - dist)  # penalize heavily
    return penalty

def fitness(path_points):
    pts = np.vstack([start, path_points, goal])
    return path_length(pts) + collision_penalty(pts)

# --- PSO Parameters ---
w = 0.7        # inertia
c1 = 1.5       # cognitive weight
c2 = 1.5       # social weight

# --- Initialization ---
positions = np.random.uniform(0, 10, (n_particles, n_waypoints, 2))
velocities = np.random.uniform(-1, 1, (n_particles, n_waypoints, 2))
pbest_positions = positions.copy()
pbest_scores = np.array([fitness(p) for p in positions])
gbest_index = np.argmin(pbest_scores)
gbest_position = pbest_positions[gbest_index].copy()

# --- PSO loop ---
for iter in range(max_iters):
    for i in range(n_particles):
        # Update velocity
        r1, r2 = np.random.rand(), np.random.rand()
        velocities[i] = (
            w * velocities[i] +
            c1 * r1 * (pbest_positions[i] - positions[i]) +
            c2 * r2 * (gbest_position - positions[i])
        )
        # Update position
        positions[i] += velocities[i]
        positions[i] = np.clip(positions[i], 0, 10)  # keep within map bounds

        # Evaluate fitness
        score = fitness(positions[i])
        if score < pbest_scores[i]:
            pbest_scores[i] = score
            pbest_positions[i] = positions[i].copy()

    # Update global best
    gbest_index = np.argmin(pbest_scores)
    gbest_position = pbest_positions[gbest_index].copy()

    if iter % 10 == 0:
        print(f"Iteration {iter}: Best Distance = {pbest_scores[gbest_index]:.2f}")

# --- Results ---
print("\nOptimized Path Length:", pbest_scores[gbest_index])

# --- Visualization ---
best_path = np.vstack([start, gbest_position, goal])
plt.figure(figsize=(6,6))
plt.plot(best_path[:,0], best_path[:,1], 'b-o', label='Optimized Path')
plt.scatter(start[0], start[1], color='green', s=100, label='Start')
plt.scatter(goal[0], goal[1], color='red', s=100, label='Goal')

# Draw obstacles
for obs in obstacles:
    circle = plt.Circle(obs["center"], obs["radius"], color='r', alpha=0.3)
    plt.gca().add_patch(circle)

plt.title("Drone Path Optimization using PSO")
plt.xlim(-1, 11)
plt.ylim(-1, 11)
plt.legend()
plt.grid(True)
plt.show()
