import numpy as np

# -----------------------------
# Objective Function (Fitness)
# -----------------------------
def fitness(position, jobs, num_machines):
    """
    position : array representing wolf (job assignments)
    jobs : list of job processing times
    num_machines : number of machines
    """
    machine_times = [0] * num_machines
    for job_id, machine_id in enumerate(position):
        machine_times[int(machine_id)] += jobs[job_id]
    return max(machine_times)   # makespan (want to minimize)

# -----------------------------
# Grey Wolf Optimizer
# -----------------------------
def gwo(num_wolves, max_iter, jobs, num_machines):
    num_jobs = len(jobs)

    # Initialize wolves randomly (each job assigned to a random machine)
    wolves = np.random.randint(0, num_machines, (num_wolves, num_jobs))

    # Initialize alpha, beta, delta (best three solutions)
    alpha, beta, delta = None, None, None
    alpha_score, beta_score, delta_score = float("inf"), float("inf"), float("inf")

    # Main Loop
    for iter in range(max_iter):
        for i in range(num_wolves):
            score = fitness(wolves[i], jobs, num_machines)

            # Update alpha, beta, delta
            if score < alpha_score:
                delta, delta_score = beta, beta_score
                beta, beta_score = alpha, alpha_score
                alpha, alpha_score = wolves[i].copy(), score
            elif score < beta_score:
                delta, delta_score = beta, beta_score
                beta, beta_score = wolves[i].copy(), score
            elif score < delta_score:
                delta, delta_score = wolves[i].copy(), score

        # Update wolves positions
        a = 2 - 2 * (iter / max_iter)  # linearly decreases from 2 → 0
        for i in range(num_wolves):
            for j in range(num_jobs):
                # For each job, update based on alpha, beta, delta
                r1, r2 = np.random.rand(), np.random.rand()
                A1, C1 = 2 * a * r1 - a, 2 * r2
                D_alpha = abs(C1 * alpha[j] - wolves[i][j])
                X1 = alpha[j] - A1 * D_alpha

                r1, r2 = np.random.rand(), np.random.rand()
                A2, C2 = 2 * a * r1 - a, 2 * r2
                D_beta = abs(C2 * beta[j] - wolves[i][j])
                X2 = beta[j] - A2 * D_beta

                r1, r2 = np.random.rand(), np.random.rand()
                A3, C3 = 2 * a * r1 - a, 2 * r2
                D_delta = abs(C3 * delta[j] - wolves[i][j])
                X3 = delta[j] - A3 * D_delta

                # Average influence of alpha, beta, delta
                new_pos = (X1 + X2 + X3) / 3

                # Ensure job assigned to a valid machine index
                wolves[i][j] = int(np.clip(round(new_pos), 0, num_machines - 1))

    return alpha, alpha_score

# -----------------------------
# Example Run
# -----------------------------
jobs = [2, 14, 4, 16, 6, 5, 3, 7]   # job processing times
num_machines = 3

best_schedule, best_makespan = gwo(num_wolves=10, max_iter=50, jobs=jobs, num_machines=num_machines)

print("Best Schedule (job→machine):", best_schedule)
print("Best Makespan:", best_makespan)
